using Newtonsoft.Json.Linq;
using System;
using System.Collections.Generic;
using System.Dynamic;
using System.Linq;

namespace Distance.Shark
{
    /// <summary>
    /// This class represents TSHARK decoder that accepts a collection of fields to extract.
    /// </summary>
    public class TSharkFieldDecoderProcess : TSharkProcess<Packet>
    {
        private List<string> m_fields;
        /// <summary>
        /// Gets a collection of fields that is to be exported by TSHARK.
        /// </summary>
        public IList<string> Fields { get => m_fields; }


        public TSharkFieldDecoderProcess() : base()
        {
            m_fields = new List<string>();
        }

        public TSharkFieldDecoderProcess(string pipeName) : base(pipeName)
        {
            m_fields = new List<string>();
        }

        public TSharkFieldDecoderProcess(IEnumerable<string> fields) : base()
        {
            m_fields = new List<string>(fields);
        }

        public TSharkFieldDecoderProcess(string pipeName, IEnumerable<string> fields) : base(pipeName)
        {
            m_fields = new List<string>(fields);
        }

        protected override string GetOutputFilter()
        {
            var fields = String.Join(" ", m_fields.Select(x => $"-e {x}"));
            var exportedFields = $"-e { Field.Frame.Number} -e { Field.Frame.Protocols} { fields}";
            return exportedFields;
        }

        /// <summary>
        /// Gets the <see cref="Packet"/> object for the result line generated by the TSHARK process.
        /// </summary>
        /// <param name="line">Result line generated by the associated TSHARK process.</param>
        /// <returns><see cref="Packet"/> object for the result line generated by the TSHARK process.</returns>
        protected override Packet GetResult(string line)
        {
            return DecodeJsonLine(line);
        }

        public static Packet DecodeJsonLine(string line)
        {
            var jsonObject = JToken.Parse(line);
            var fields = jsonObject["layers"].ToDictionary(y => ((JProperty)y).Name, y => ((JProperty)y).Value);
            dynamic result = new ExpandoObject();
            result.Timestamp = (long)jsonObject["timestamp"];

            foreach (var field in fields)
            {
                switch (field.Key)
                {
                    case "frame_number":
                        result.FrameNumber = (int)field.Value.First;
                        break;
                    case "frame_protocols":
                        result.FrameProtocols = (string)field.Value.First;
                        break;
                    default:
                        result[field.Key] = (string)field.Value.First;
                        break;
                }
            }
            return result;
        }
    }
}
